- 计算虚拟化相关概念技术(计算虚拟化概念、CPU虚拟化、内存虚拟化、I/O虚拟化、FusionCompute计算虚拟化介绍)
- 计算虚拟化功能特性

什么是虚拟化
---

- 虚拟化是一个抽象层，它打破了物理硬件和操作系统之间的硬性连接
- 虚拟基础结构是一种企业解决方案，可以提供流畅、强大的计算能力，从而最大限度利用资源和节约成本
- 虚拟机是虚拟基础结构的重要元素，虚拟化可以在同一台主机上独立并行运行不同操作系统和应用程序的多台虚拟机
- 使用虚拟化，可以动态移动资源和处理能力

|虚拟化前|虚拟化后|
|:---|:---|
|1、IT资源独立；|1、资源抽象成共享资源池|
|2、操作系统必须和硬件紧密耦合|2、上层操作系统与硬件解耦，操作系统从资源池中分配资源|

- 虚拟化在云计算基础。虚拟化使得一台主机上可以运行多台虚拟机，虚拟机共享主机CPU，内存，IO硬件资源，但逻辑上虚拟机之间是相互隔离的
- 计算方面　虚拟化是指对计算资源的抽象，提供一个或多个操作环境，实现资源模拟、隔离或共享
本质上，虚拟化就是由位于下层的软件模块，通过向上一次软件模块提供一个与它原先所期待的运行环境完全一致的接口的方法，抽象出一个虚拟的软件或硬件接口，使得上层软件可以直接运行在虚拟环境上。通过空间上的分割、时间上的分时以及模拟，虚拟化可将一份资源抽象成多份，亦可将多份资源抽象成为一份。

分区　隔离　封装　相对硬件独立

分区　分区意味着虚拟化层为多个虚拟机划分服务器资源的能力；每个虚拟机可以同时运行一个单独的操作系统(相同或不同的操作系统)；每个操作系统只能看到虚拟化层为其提供的虚拟硬件(CPU 内存　网卡　磁盘等)

隔离　虚拟机是相互隔离的
1. 一个虚拟机的崩溃或者故障不会影响同一台服务器上其它虚拟机
2. 可以进行资源控制以提供性能隔离，可以设置每个虚拟最大最小资源使用量
3. 可在单一服务器上运行多个负载/应用程序/操作系统

封装　封装意味着整个虚拟机(硬件配置、BIOS配置、内存状态、磁盘状态、CPU状态等)存储在独立与物理硬件的一小组文件中，我们可以随时复制几个文件就可以根据需要复制、保存和移动虚拟机

相对于硬件独立　由于虚拟机运行在虚拟化层上，虚拟机可以在任意x86服务器(IBM/Dell/HP等厂家)上运行而无需进行任何修改。打破了操作系统和硬件以及应用程序和操作系统/硬件之间的约束

计算虚拟化技术的分类

|分类标准|分类|详解|
|:---|:---|:---|
|虚拟化对象|CPU虚拟化|虚拟机指令被执行，且效率接近于物理机|
||内存虚拟化|虚拟机内存空间之间的隔离，使每个虚拟机都认为自己拥有了整个内存地址，且效率也能接近虚拟机|
||I/O虚拟化|不仅让虚拟访问到所需资源，而且要做好虚拟机之间的隔离，同时减轻由于虚拟化带来的开销|
|虚拟化过程|全虚拟化|使用VMM实现CPU内存设备I/O的虚拟化，guest OS和计算机系统都不需要修改，该方式兼容性好，但CPU处理开销最高|
||半虚拟化|使用VMM实现CPU和内存虚拟化，设备I/O虚拟化由GuestOS实现，需要修改Guest OS,使其能够和VMM协同工作，该方式兼容性差，但是性能好|
||硬件辅助虚拟化|借助硬件(主要是处理器)支持来实现高效的全虚拟化，该方式不需要修改Guest OS，兼容性好|

CPU虚拟化
---

CPU虚拟化需要解决的问题　如何模拟CPU指令(敏感指令；特权指令)　　如何让多个VM共享CPU

系统关键资源　处理器呈现给软件的接口是指令集和寄存器。而I/O设备呈现给软件的接口是状态和控制寄存器。这些都是系统资源，其中影响处理器和设备状态和行为的寄存器称为关键资源。

FusionCompute计算虚拟化采用的是KVM技术，KVM的CPU虚拟化是基于CPU辅助的全虚拟化方案，需要CPU虚拟化的支持

```txt
                                                                 ring3 用户应用程序--指令--
ring 3 应用程序------->     | ring3  用户应用程序--指令------------  ring2                  |
ring 2          　   |     | ring2                            |　 ring1        　        |
ring 1           　  |     | ring1  Guest OS－捕获、翻译、模拟   |　 ring0  　Guest OS      |
ring 0 OS kernel 　  |     | ring0  VMM                       |　root模式　　VMM          |
 　         |        |  　 |              |    　　            |             |　      　  |
      X86 硬 件 结 构       |       X86 硬 件 结 构      　　    |　　　　　X86 硬 件 结 构　　|
                        　 |                                  |            　　          |
  　  无虚拟化　 　　  　　   | 　　　  基于二进制翻译的全虚拟化      |        硬件辅助全虚拟化    |
```
FusionCompute采用的是硬件辅助全虚拟化

内存虚拟化问题

原生操作系统对内存的认识与管理达成以下共识：内存都是从物理地址0开始的；内存是连续的

内存虚拟化要解决的两个问题　物理地址０只有一个，无法满足所有客户机从0开始的需求；地址连续　虽然可以分配连续的物理地址但是使用率不高，缺乏灵活性

KVM中，虚拟机物理内存即为qemu-kvm进程所占用的内存空间。KVM使用CPU辅助的内存虚拟化方式。在Intel平台，其内存虚拟化实现方式为EPT(Extended Tables)技术，AMD　提供的类似技术叫NPT Nested Page Tables

虚拟地址GVA　　　　　　　　　　　　　　　　　客户机物理地址HVA
　　　|           <---CPU查找、映射---->       |
客户物理地址GPA                         物理机真实地址HPA

G Guest  V Virtual  A Address  H Host  P Physical

影子页表

由于宿主机MMU不能直接装载客户机的页表来进行内存访问，所以当客户机访问宿主物理机内存时，需要进行多次地址转换。

客户机虚拟地址GVA--转换-->客户机物理地址GPA--查找、映射-->宿主机虚拟地址HVA---转换-->宿主机物理地址HPA

Intel的CPU提供了EPT(Extended Page Tables 扩展页表)技术，直接在硬件上支持GVA-->GPA--->HPA地址转换，从而降低内存虚拟化实现的复杂度，也进一步提升内存虚拟化性能

透明大页THP

大页　页大小２M；提高了TLB命中率；减少内存访问时间；申请大内存区效率更高；访问大内存，减少页表项大小，提高CPU cache效率

透明　对使用者完全透明，不依赖任何库，大小也混合；兼容ksm,swap需要共享或swap时拆分成4k大小页面；兼容EPT/NPT，兼容影子页表

x86架构的CPU默认使用4KB大小内存页面，但也支持较大内存页，Linux 2.6及以上内核支持Huge Page(2MB的大页)，如果在系统中使用了Huge page则内存也数量会减少，从而需要更少的页表page table,节约了页表所占用的内存数量，并且所需的地址转换也减少了，TLB缓存失效次数就减少了，从而提高了内存访问性能。由于地址转换信息保存在CPU缓存中，Huge page的使用使地址转换信息减少，从而减少了CPU缓存的使用，减轻了CPU缓存压力，让CPU缓存能够用更多的于处理应用程序数据的缓存，从整体上提升了系统的性能

I/O虚拟化问题

- 设备发现　需要控制各虚拟机能够访问的设备
- 访问截获 通过I/O端口或者MMIO对设备的访问；设备通过DMA与内存进行数据交换

